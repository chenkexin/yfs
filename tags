!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BBLOCK	inode_manager.h	92;"	d
BLOCK_NUM	inode_manager.h	19;"	d
BLOCK_SIZE	inode_manager.h	18;"	d
BPB	inode_manager.h	89;"	d
CB_MASK	rpc/pollmgr.h	/^	CB_MASK = ~0x11,$/;"	e	enum:__anon3
CB_NONE	rpc/pollmgr.h	/^	CB_NONE = 0x0,$/;"	e	enum:__anon3
CB_RDONLY	rpc/pollmgr.h	/^	CB_RDONLY = 0x1,$/;"	e	enum:__anon3
CB_RDWR	rpc/pollmgr.h	/^	CB_RDWR = 0x11,$/;"	e	enum:__anon3
CB_WRONLY	rpc/pollmgr.h	/^	CB_WRONLY = 0x10,$/;"	e	enum:__anon3
CC	GNUmakefile	/^CC = g++$/;"	m
CLOCK_MONOTONIC	gettime.cc	/^	CLOCK_MONOTONIC,$/;"	e	enum:__anon6	file:
CLOCK_MONOTONIC	gettime.h	/^	CLOCK_MONOTONIC,$/;"	e	enum:__anon1
CLOCK_PROCESS_CPUTIME_ID	gettime.cc	/^	CLOCK_PROCESS_CPUTIME_ID,$/;"	e	enum:__anon6	file:
CLOCK_PROCESS_CPUTIME_ID	gettime.h	/^	CLOCK_PROCESS_CPUTIME_ID,$/;"	e	enum:__anon1
CLOCK_REALTIME	gettime.cc	/^	CLOCK_REALTIME,$/;"	e	enum:__anon6	file:
CLOCK_REALTIME	gettime.h	/^	CLOCK_REALTIME,$/;"	e	enum:__anon1
CLOCK_THREAD_CPUTIME_ID	gettime.cc	/^	CLOCK_THREAD_CPUTIME_ID$/;"	e	enum:__anon6	file:
CLOCK_THREAD_CPUTIME_ID	gettime.h	/^	CLOCK_THREAD_CPUTIME_ID$/;"	e	enum:__anon1
CXX	GNUmakefile	/^CXX = g++$/;"	m
CXXFLAGS	GNUmakefile	/^CXXFLAGS =  -g -MMD -Wall -I. -I$(RPC) -DLAB=$(LAB) -DSOL=$(SOL) -D_FILE_OFFSET_BITS=64$/;"	m
Condition	lock_server.h	/^        Condition( MutexLock& mutex ): mutex_(mutex)$/;"	f	class:Condition
Condition	lock_server.h	/^class Condition$/;"	c
DEFAULT_RPC_SZ	rpc/marshall.h	/^	DEFAULT_RPC_SZ = 1024,$/;"	e	enum:__anon2
DISK_SIZE	inode_manager.h	17;"	d
DONE	rpc/rpc.h	/^		DONE, \/\/ duplicate of an RPC we already replied to (have reply)$/;"	e	enum:rpcs::__anon4
EPollAIO	rpc/pollmgr.cc	/^EPollAIO::EPollAIO()$/;"	f	class:EPollAIO
EPollAIO	rpc/pollmgr.h	/^class EPollAIO : public aio_mgr {$/;"	c
EXIST	yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	e	enum:yfs_client::xxstatus
EXT_RPC	yfs_client.cc	111;"	d	file:
FORGOTTEN	rpc/rpc.h	/^		FORGOTTEN,  \/\/ duplicate of an old RPC whose reply we've forgotten$/;"	e	enum:rpcs::__anon4
FUSEFLAGS	GNUmakefile	/^FUSEFLAGS= -D_FILE_OFFSET_BITS=64 -DFUSE_USE_VERSION=25 -I\/usr\/local\/include\/fuse -I\/usr\/include\/fuse$/;"	m
IBLOCK	inode_manager.h	86;"	d
INODE_NUM	inode_manager.h	80;"	d
INPROGRESS	rpc/rpc.h	/^		INPROGRESS, \/\/ duplicate of an RPC we're still processing$/;"	e	enum:rpcs::__anon4
IOERR	extent_protocol.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR };$/;"	e	enum:extent_protocol::xxstatus
IOERR	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
IOERR	yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	e	enum:yfs_client::xxstatus
IPB	inode_manager.h	83;"	d
Instance	rpc/pollmgr.cc	/^PollMgr::Instance()$/;"	f	class:PollMgr
JSL_DBG_1	rpc/jsl_log.h	/^	JSL_DBG_1 = 1, \/\/ Critical$/;"	e	enum:dbcode
JSL_DBG_2	rpc/jsl_log.h	/^	JSL_DBG_2 = 2, \/\/ Error$/;"	e	enum:dbcode
JSL_DBG_3	rpc/jsl_log.h	/^	JSL_DBG_3 = 3, \/\/ Info$/;"	e	enum:dbcode
JSL_DBG_4	rpc/jsl_log.h	/^	JSL_DBG_4 = 4, \/\/ Debugging$/;"	e	enum:dbcode
JSL_DBG_OFF	rpc/jsl_log.h	/^	JSL_DBG_OFF = 0,$/;"	e	enum:dbcode
JSL_DEBUG_LEVEL	rpc/jsl_log.cc	/^int JSL_DEBUG_LEVEL = 0;$/;"	v
LAB	GNUmakefile	/^LAB=4$/;"	m
LAB1GE	GNUmakefile	/^LAB1GE=$(shell expr $(LAB) \\>\\= 1)$/;"	m
LAB2GE	GNUmakefile	/^LAB2GE=$(shell expr $(LAB) \\>\\= 2)$/;"	m
LAB3GE	GNUmakefile	/^LAB3GE=$(shell expr $(LAB) \\>\\= 3)$/;"	m
LAB4GE	GNUmakefile	/^LAB4GE=$(shell expr $(LAB) \\>\\= 4)$/;"	m
LAB5GE	GNUmakefile	/^LAB5GE=$(shell expr $(LAB) \\>\\= 5)$/;"	m
LAB6GE	GNUmakefile	/^LAB6GE=$(shell expr $(LAB) \\>\\= 6)$/;"	m
LAB7GE	GNUmakefile	/^LAB7GE=$(shell expr $(LAB) \\>\\= 7)$/;"	m
LDFLAGS	GNUmakefile	/^LDFLAGS = -L. -L\/usr\/local\/lib$/;"	m
LDLIBS	GNUmakefile	/^LDLIBS = -lpthread $/;"	m
MACFLAGS	GNUmakefile	/^  MACFLAGS= -D__FreeBSD__=10$/;"	m
MACFLAGS	GNUmakefile	/^  MACFLAGS=$/;"	m
MAXFILE	inode_manager.h	96;"	d
MAX_PDU	rpc/connection.cc	17;"	d	file:
MAX_POLL_FDS	rpc/pollmgr.h	11;"	d
MIN	inode_manager.cc	324;"	d	file:
MutexLock	lock_server.h	/^    MutexLock()$/;"	f	class:MutexLock
MutexLock	lock_server.h	/^class MutexLock$/;"	c
MutexLockGuard	lock_server.h	/^        MutexLockGuard(MutexLock& mutex): mutex_(mutex)$/;"	f	class:MutexLockGuard
MutexLockGuard	lock_server.h	/^class MutexLockGuard$/;"	c
MutexLockGuard	lock_server.h	57;"	d
NDIRECT	inode_manager.h	94;"	d
NEW	rpc/rpc.h	/^		NEW,  \/\/ new RPC, not a duplicate$/;"	e	enum:rpcs::__anon4
NINDIRECT	inode_manager.h	95;"	d
NOENT	extent_protocol.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR };$/;"	e	enum:extent_protocol::xxstatus
NOENT	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
NOENT	yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	e	enum:yfs_client::xxstatus
NUM_CL	rpc/rpctest.cc	14;"	d	file:
OK	extent_protocol.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR };$/;"	e	enum:extent_protocol::xxstatus
OK	lock_protocol.h	/^    enum xxstatus { OK, RPCERR, RESET };$/;"	e	enum:rlock_protocol::xxstatus
OK	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
OK	yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	e	enum:yfs_client::xxstatus
PollMgr	rpc/pollmgr.cc	/^PollMgr::PollMgr() : pending_change_(false)$/;"	f	class:PollMgr
PollMgr	rpc/pollmgr.h	/^class PollMgr {$/;"	c
PollMgrInit	rpc/pollmgr.cc	/^PollMgrInit()$/;"	f
RESET	lock_protocol.h	/^    enum xxstatus { OK, RPCERR, RESET };$/;"	e	enum:rlock_protocol::xxstatus
RETRY	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
RPC	GNUmakefile	/^RPC=.\/rpc$/;"	m
RPCERR	extent_protocol.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR };$/;"	e	enum:extent_protocol::xxstatus
RPCERR	lock_protocol.h	/^    enum xxstatus { OK, RPCERR, RESET };$/;"	e	enum:rlock_protocol::xxstatus
RPCERR	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	e	enum:lock_protocol::xxstatus
RPCERR	yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	e	enum:yfs_client::xxstatus
RPC_HEADER_SZ	rpc/marshall.h	/^	RPC_HEADER_SZ = static_max<sizeof(req_header), sizeof(reply_header)>::value + sizeof(rpc_sz_t) + sizeof(rpc_checksum_t)$/;"	e	enum:__anon2
SOL	GNUmakefile	/^SOL=0$/;"	m
ScopedLock	rpc/slock.h	/^		ScopedLock(pthread_mutex_t *m): m_(m) {$/;"	f	struct:ScopedLock
ScopedLock	rpc/slock.h	/^struct ScopedLock {$/;"	s
SelectAIO	rpc/pollmgr.cc	/^SelectAIO::SelectAIO() : highfds_(0)$/;"	f	class:SelectAIO
SelectAIO	rpc/pollmgr.h	/^class SelectAIO : public aio_mgr {$/;"	c
TO	rpc/rpc.h	/^		struct TO {$/;"	s	class:rpcc
TPRINTF_H	tprintf.h	2;"	d
T_DIR	extent_protocol.h	/^    T_DIR = 1,$/;"	e	enum:extent_protocol::types
T_FILE	extent_protocol.h	/^    T_FILE$/;"	e	enum:extent_protocol::types
ThrPool	rpc/thr_pool.cc	/^ThrPool::ThrPool(int sz, bool blocking)$/;"	f	class:ThrPool
ThrPool	rpc/thr_pool.h	/^class ThrPool {$/;"	c
VERIFY	lang/verify.h	10;"	d
VERIFY	lang/verify.h	12;"	d
XXX	rpc/method_thread.h	/^		class XXX {$/;"	c	namespace:__anon5
__JSL_LOG_H__	rpc/jsl_log.h	2;"	d
__SCOPED_LOCK__	rpc/slock.h	2;"	d
__THR_POOL__	rpc/thr_pool.h	2;"	d
__clock_gettime_inf	gettime.cc	/^static mach_timebase_info_data_t __clock_gettime_inf;$/;"	v	file:
_buf	rpc/marshall.h	/^		char *_buf;     \/\/ Base of the raw bytes buffer (dynamically readjusted)$/;"	m	class:marshall
_buf	rpc/marshall.h	/^		char *_buf;$/;"	m	class:unmarshall
_capa	rpc/marshall.h	/^		int _capa;      \/\/ Capacity of the buffer$/;"	m	class:marshall
_ind	rpc/marshall.h	/^		int _ind;       \/\/ Read\/write head position$/;"	m	class:marshall
_ind	rpc/marshall.h	/^		int _ind;$/;"	m	class:unmarshall
_ok	rpc/marshall.h	/^		bool _ok;$/;"	m	class:unmarshall
_sz	rpc/marshall.h	/^		int _sz;$/;"	m	class:unmarshall
a	lock_tester.cc	/^lock_protocol::lockid_t a = 1;$/;"	v
a	rpc/thr_pool.h	/^			void *a; \/\/function arguments$/;"	m	struct:ThrPool::job_t
a1	rpc/method_thread.h	/^				A1 a1;$/;"	m	class:__anon5::XXX
a2	rpc/method_thread.h	/^				A2  a2;$/;"	m	class:__anon5::XXX
accept_conn	rpc/connection.cc	/^tcpsconn::accept_conn()$/;"	f	class:tcpsconn
acquire	lock_client.cc	/^lock_client::acquire(lock_protocol::lockid_t lid)$/;"	f	class:lock_client
acquire	lock_client_cache.cc	/^lock_client_cache::acquire(lock_protocol::lockid_t lid, int cid)$/;"	f	class:lock_client_cache
acquire	lock_protocol.h	/^    acquire = 0x7001,$/;"	e	enum:lock_protocol::rpc_numbers
acquire	lock_server.cc	/^lock_protocol::status lock_server::acquire(int clt, lock_protocol::lockid_t lid, int &r)$/;"	f	class:lock_server
acquire	lock_server_cache.cc	/^int lock_server_cache::acquire(std::string id, lock_protocol::lockid_t lid, $/;"	f	class:lock_server_cache
acquiring	lock_client_cache.h	/^        acquiring,$/;"	e	enum:c_state::c_lock_state
addJob	rpc/thr_pool.cc	/^ThrPool::addJob(void *(*f)(void *), void *a)$/;"	f	class:ThrPool
addObjJob	rpc/thr_pool.h	/^ThrPool::addObjJob(C *o, void (C::*m)(A), A a)$/;"	f	class:ThrPool
add_callback	rpc/pollmgr.cc	/^PollMgr::add_callback(int fd, poll_flag flag, aio_callback *ch)$/;"	f	class:PollMgr
add_reply	rpc/rpc.cc	/^rpcs::add_reply(unsigned int clt_nonce, unsigned int xid, char *b, int sz)$/;"	f	class:rpcs
add_timespec	rpc/rpc.cc	/^add_timespec(const struct timespec &a, int b, struct timespec *result)$/;"	f
aio_	rpc/pollmgr.h	/^		aio_mgr *aio_;$/;"	m	class:PollMgr
aio_callback	rpc/pollmgr.h	/^class aio_callback {$/;"	c
aio_mgr	rpc/pollmgr.h	/^class aio_mgr {$/;"	c
algorithm_h	lang/algorithm.h	4;"	d
alloc_block	inode_manager.cc	/^block_manager::alloc_block()$/;"	f	class:block_manager
alloc_inode	inode_manager.cc	/^inode_manager::alloc_inode(uint32_t type)$/;"	f	class:inode_manager
append	test-lab-2-b.pl	/^sub append {$/;"	s
append1	test-lab-3-a.c	/^append1(const char *d, const char *f, const char *in)$/;"	f
append1	test-lab-3-b.c	/^append1(const char *d, const char *f, const char *in)$/;"	f
atime	extent_protocol.h	/^    unsigned int atime;$/;"	m	struct:extent_protocol::attr
atime	inode_manager.h	/^  unsigned int atime;$/;"	m	struct:inode
atime	yfs_client.h	/^    unsigned long atime;$/;"	m	struct:yfs_client::dirinfo
atime	yfs_client.h	/^    unsigned long atime;$/;"	m	struct:yfs_client::fileinfo
atmostonce_failure	rpc/rpc.h	/^		static const int atmostonce_failure = -4;$/;"	m	class:rpc_const
attr	extent_protocol.h	/^  struct attr {$/;"	s	class:extent_protocol
attr	rpc/rpctest.cc	/^pthread_attr_t attr;$/;"	v
attr_	rpc/thr_pool.h	/^		pthread_attr_t attr_;$/;"	m	class:ThrPool
b	lock_tester.cc	/^lock_protocol::lockid_t b = 2;$/;"	v
big	test-lab-3-a.c	/^char big[20001];$/;"	v
bind	rpc/rpc.cc	/^rpcc::bind(TO to)$/;"	f	class:rpcc
bind	rpc/rpc.h	/^		static const unsigned int bind = 1;   \/\/ handler number reserved for bind$/;"	m	class:rpc_const
bind_done_	rpc/rpc.h	/^		bool bind_done_;$/;"	m	class:rpcc
bind_failure	rpc/rpc.h	/^		static const int bind_failure = -6;$/;"	m	class:rpc_const
block_manager	inode_manager.cc	/^block_manager::block_manager()$/;"	f	class:block_manager
block_manager	inode_manager.h	/^class block_manager {$/;"	c
block_remove_fd	rpc/pollmgr.cc	/^PollMgr::block_remove_fd(int fd)$/;"	f	class:PollMgr
blockadd_	rpc/thr_pool.h	/^		bool blockadd_;$/;"	m	class:ThrPool
blockid_t	inode_manager.h	/^typedef uint32_t blockid_t;$/;"	t
blocks	inode_manager.h	/^  blockid_t blocks[NDIRECT+1];   \/\/ Data block addresses$/;"	m	struct:inode
blocks	inode_manager.h	/^  unsigned char blocks[BLOCK_NUM][BLOCK_SIZE];$/;"	m	class:disk
bm	inode_manager.h	/^  block_manager *bm;$/;"	m	class:inode_manager
buf	rpc/connection.h	/^			char *buf;$/;"	m	struct:connection::charbuf
buf	rpc/rpc.h	/^		char *buf;      \/\/ the reply buffer$/;"	m	struct:rpcs::reply_t
buf	rpc/rpc.h	/^		char *buf;$/;"	m	struct:rpcs::djob_t
buf	rpc/rpc.h	/^                    std::string buf;$/;"	m	struct:rpcc::request
bundle	rpc/connection.h	/^	bundle(chanmgr *m, int s, int l):mgr(m),tcp(s),lossy(l) {}$/;"	f	struct:bundle
bundle	rpc/connection.h	/^struct bundle {$/;"	s
c	lock_tester.cc	/^lock_protocol::lockid_t c = 3;$/;"	v
c	rpc/rpc.h	/^			pthread_cond_t c;$/;"	m	struct:rpcc::caller
c_lockInfo	lock_client_cache.h	/^   c_lockInfo():lock_state(c_state::none){$/;"	f	class:c_lockInfo
c_lockInfo	lock_client_cache.h	/^class c_lockInfo$/;"	c
c_lock_state	lock_client_cache.h	/^    enum c_lock_state{$/;"	g	class:c_state
c_state	lock_client_cache.h	/^class c_state$/;"	c
call	rpc/rpc.h	/^rpcc::call(unsigned int proc, R & r, TO to) $/;"	f	class:rpcc
call	rpc/rpc.h	/^rpcc::call(unsigned int proc, const A1 & a1, R & r, TO to) $/;"	f	class:rpcc
call	rpc/rpc.h	/^rpcc::call(unsigned int proc, const A1 & a1, const A2 & a2,$/;"	f	class:rpcc
call1	rpc/rpc.cc	/^rpcc::call1(unsigned int proc, marshall &req, unmarshall &rep,$/;"	f	class:rpcc
call_m	rpc/rpc.h	/^rpcc::call_m(unsigned int proc, marshall &req, R & r, TO to) $/;"	f	class:rpcc
callbacks_	rpc/pollmgr.h	/^		aio_callback *callbacks_[MAX_POLL_FDS];$/;"	m	class:PollMgr
caller	rpc/rpc.cc	/^rpcc::caller::caller(unsigned int xxid, unmarshall *xun)$/;"	f	class:rpcc::caller
caller	rpc/rpc.h	/^		struct caller {$/;"	s	class:rpcc
calls_	rpc/rpc.h	/^		std::map<int, caller *> calls_;$/;"	m	class:rpcc
cancel	rpc/rpc.cc	/^rpcc::cancel(void)$/;"	f	class:rpcc
cancel_failure	rpc/rpc.h	/^		static const int cancel_failure = -7;$/;"	m	class:rpc_const
cb_present	rpc/rpc.h	/^		bool cb_present; \/\/ whether the reply buffer is valid$/;"	m	struct:rpcs::reply_t
chan_	rpc/rpc.h	/^		connection *chan_;$/;"	m	class:rpcc
chan_m_	rpc/rpc.h	/^		pthread_mutex_t chan_m_;$/;"	m	class:rpcc
changedone_c_	rpc/pollmgr.h	/^		pthread_cond_t changedone_c_;$/;"	m	class:PollMgr
chanmgr	rpc/connection.h	/^class chanmgr {$/;"	c
channo	rpc/connection.h	/^		int channo() { return fd_; }$/;"	f	class:connection
charbuf	rpc/connection.h	/^			charbuf (char *b, int s) : buf(b), sz(s), solong(0){}$/;"	f	struct:connection::charbuf
charbuf	rpc/connection.h	/^			charbuf(): buf(NULL), sz(0), solong(0) {}$/;"	f	struct:connection::charbuf
charbuf	rpc/connection.h	/^		struct charbuf {$/;"	s	class:connection
check1	test-lab-3-a.c	/^check1(const char *d, const char *f, const char *in)$/;"	f
check1	test-lab-3-b.c	/^check1(const char *d, const char *f, const char *in)$/;"	f
check_grant	lock_tester.cc	/^check_grant(lock_protocol::lockid_t lid)$/;"	f
check_release	lock_tester.cc	/^check_release(lock_protocol::lockid_t lid)$/;"	f
checkcontent	test-lab-2-b.pl	/^sub checkcontent {$/;"	s
checkduplicate_and_update	rpc/rpc.cc	/^rpcs::checkduplicate_and_update(unsigned int clt_nonce, unsigned int xid,$/;"	f	class:rpcs
checkn	test-lab-3-a.c	/^checkn(const char *d, const char *prefix, int nf)$/;"	f
checkn	test-lab-3-b.c	/^checkn(const char *d, const char *prefix, int nf)$/;"	f
checknot	test-lab-2-b.pl	/^sub checknot {$/;"	s
checknot	test-lab-3-a.c	/^checknot(const char *d, const char *f)$/;"	f
checknot	test-lab-3-b.c	/^checknot(const char *d, const char *f)$/;"	f
checkread	test-lab-3-a.c	/^checkread(const char *d, const char *f, int start, int n, char c)$/;"	f
cl	extent_client.h	/^  rpcc *cl;$/;"	m	class:extent_client
cl	handle.h	/^  rpcc *cl;$/;"	m	struct:hinfo
cl	lock_client.h	/^  rpcc *cl;$/;"	m	class:lock_client
cl_mutex	handle.h	/^  pthread_mutex_t cl_mutex;$/;"	m	struct:hinfo
clean_files	GNUmakefile	/^clean_files=rpc\/rpctest rpc\/*.o rpc\/*.d rpc\/librpc.a *.o *.d yfs_client extent_server lock_server lock_tester lock_demo rpctest test-lab-3-a test-lab-3-b test-lab-3-c rsm_tester lab1_tester$/;"	m
clear	rpc/rpc.h	/^                    void clear() { buf.clear(); xid = -1; }$/;"	f	struct:rpcc::request
clearbit	lock_server.cc	/^void s_lockInfo::clearbit()$/;"	f	class:s_lockInfo
client1	rpc/rpctest.cc	/^client1(void *xx)$/;"	f
client2	rpc/rpctest.cc	/^client2(void *xx)$/;"	f
client3	rpc/rpctest.cc	/^client3(void *xx)$/;"	f
client_id	lock_server.h	/^        string client_id;\/\/this is used to find the client rpc connection$/;"	m	class:s_lockInfo
clients	rpc/rpctest.cc	/^rpcc *clients[NUM_CL];  \/\/ client rpc object$/;"	v
clock_gettime	gettime.cc	/^int clock_gettime(clockid_t clk_id, struct timespec *tp) {$/;"	f
clock_gettime	gettime.cc	65;"	d	file:
clockid_t	gettime.cc	/^} clockid_t;$/;"	t	typeref:enum:__anon6	file:
clockid_t	gettime.h	/^} clockid_t;$/;"	t	typeref:enum:__anon1
closeconn	rpc/connection.cc	/^connection::closeconn()$/;"	f	class:connection
clt_nonce	rpc/marshall.h	/^	unsigned int clt_nonce;$/;"	m	struct:req_header
clt_nonce_	rpc/rpc.h	/^		unsigned int clt_nonce_;$/;"	m	class:rpcc
cmp_timespec	rpc/rpc.cc	/^cmp_timespec(const struct timespec &a, const struct timespec &b)$/;"	f
compar	test-lab-3-a.c	/^compar(const void *xa, const void *xb)$/;"	f
compar	test-lab-3-b.c	/^compar(const void *xa, const void *xb)$/;"	f
compare	rpc/connection.cc	/^connection::compare(connection *another)$/;"	f	class:connection
concurrent_test	rpc/rpctest.cc	/^concurrent_test(int nt)$/;"	f
cond_	lock_client_cache.h	/^  Condition *cond_;$/;"	m	class:lock_client_cache
cond_	lock_server_cache.h	/^  Condition cond_;$/;"	m	class:lock_server_cache
conn	rpc/rpc.h	/^		connection *conn;$/;"	m	struct:rpcs::djob_t
connect_to_dst	rpc/connection.cc	/^connect_to_dst(const sockaddr_in &dst, chanmgr *mgr, int lossy)$/;"	f
connection	rpc/connection.cc	/^connection::connection(chanmgr *m1, int f1, int l1) $/;"	f	class:connection
connection	rpc/connection.h	/^class connection : public aio_callback {$/;"	c
connection_h	rpc/connection.h	2;"	d
conns_	rpc/connection.h	/^		std::map<int, connection *> conns_;$/;"	m	class:tcpsconn
conns_	rpc/rpc.h	/^	std::map<unsigned int, connection *> conns_;$/;"	m	class:rpcs
conss_m_	rpc/rpc.h	/^	pthread_mutex_t conss_m_; \/\/ protect conns_$/;"	m	class:rpcs
count_m_	rpc/rpc.h	/^	pthread_mutex_t count_m_;  \/\/protect modification of counts$/;"	m	class:rpcs
count_mutex	lock_tester.cc	/^pthread_mutex_t count_mutex;$/;"	v
counting_	rpc/rpc.h	/^	const int counting_;$/;"	m	class:rpcs
counts_	rpc/rpc.h	/^	std::map<int, int> counts_;$/;"	m	class:rpcs
create	extent_client.cc	/^extent_client::create(uint32_t type, extent_protocol::extentid_t &eid)$/;"	f	class:extent_client
create	extent_protocol.h	/^    create$/;"	e	enum:extent_protocol::rpc_numbers
create	extent_server.cc	/^int extent_server::create(uint32_t type, extent_protocol::extentid_t &id)$/;"	f	class:extent_server
create	yfs_client.cc	/^yfs_client::create(inum parent, const char *name, mode_t mode, inum &ino_out, uint32_t type)$/;"	f	class:yfs_client
create1	test-lab-3-a.c	/^create1(const char *d, const char *f, const char *in)$/;"	f
create1	test-lab-3-b.c	/^create1(const char *d, const char *f, const char *in)$/;"	f
create_time_	rpc/connection.h	/^                struct timeval create_time_;$/;"	m	class:connection	typeref:struct:connection::timeval
createn	test-lab-3-a.c	/^createn(const char *d, const char *prefix, int nf, bool possible_dup)$/;"	f
createn	test-lab-3-b.c	/^createn(const char *d, const char *prefix, int nf)$/;"	f
cstr	rpc/marshall.h	/^		char *cstr() { return _buf;}$/;"	f	class:marshall
cstr	rpc/marshall.h	/^		char *cstr() { return _buf;}$/;"	f	class:unmarshall
ct	lock_tester.cc	/^int ct[256];$/;"	v
ctime	extent_protocol.h	/^    unsigned int ctime;$/;"	m	struct:extent_protocol::attr
ctime	inode_manager.h	/^  unsigned int ctime;$/;"	m	struct:inode
ctime	yfs_client.h	/^    unsigned long ctime;$/;"	m	struct:yfs_client::dirinfo
ctime	yfs_client.h	/^    unsigned long ctime;$/;"	m	struct:yfs_client::fileinfo
cur_block	inode_manager.h	/^  uint32_t cur_block;$/;"	m	class:block_manager
cur_inum	inode_manager.cc	/^static int cur_inum;$/;"	v	file:
curr_counts_	rpc/rpc.h	/^	int curr_counts_;$/;"	m	class:rpcs
d	inode_manager.h	/^  disk *d;$/;"	m	class:block_manager
d1	test-lab-3-a.c	/^char d1[512], d2[512];$/;"	v
d1	test-lab-3-b.c	/^char d1[512], d2[512];$/;"	v
d2	test-lab-3-a.c	/^char d1[512], d2[512];$/;"	v
d2	test-lab-3-b.c	/^char d1[512], d2[512];$/;"	v
dbcode	rpc/jsl_log.h	/^enum dbcode {$/;"	g
dead_	rpc/connection.h	/^		bool dead_;$/;"	m	class:connection
decref	rpc/connection.cc	/^connection::decref()$/;"	f	class:connection
del	handle.h	/^  bool del;$/;"	m	struct:hinfo
del_callback	rpc/pollmgr.cc	/^PollMgr::del_callback(int fd, poll_flag flag)$/;"	f	class:PollMgr
delete_handle	handle.cc	/^handle_mgr::delete_handle(std::string m)$/;"	f	class:handle_mgr
delete_handle_wo	handle.cc	/^handle_mgr::delete_handle_wo(std::string m)$/;"	f	class:handle_mgr
deq	rpc/fifo.h	/^fifo<T>::deq(T *e)$/;"	f	class:fifo
destroy_wait_	rpc/rpc.h	/^		bool destroy_wait_;$/;"	m	class:rpcc
destroy_wait_c_	rpc/rpc.h	/^		pthread_cond_t destroy_wait_c_;$/;"	m	class:rpcc
diff_timespec	rpc/rpc.cc	/^diff_timespec(const struct timespec &end, const struct timespec &start)$/;"	f
dirbuf	fuse.cc	/^struct dirbuf {$/;"	s	file:
dirbuf_add	fuse.cc	/^void dirbuf_add(struct dirbuf *b, const char *name, fuse_ino_t ino)$/;"	f
dircheck	test-lab-2-b.pl	/^sub dircheck {$/;"	s
dircheck	test-lab-3-a.c	/^dircheck(const char *d, int nf)$/;"	f
dircheck	test-lab-3-b.c	/^dircheck(const char *d, int nf)$/;"	f
dirent	yfs_client.h	/^  struct dirent {$/;"	s	class:yfs_client
dirinfo	yfs_client.h	/^  struct dirinfo {$/;"	s	class:yfs_client
disk	inode_manager.cc	/^disk::disk()$/;"	f	class:disk
disk	inode_manager.h	/^class disk {$/;"	c
dispatch	rpc/rpc.cc	/^rpcs::dispatch(djob_t *j)$/;"	f	class:rpcs
dispatchpool_	rpc/rpc.h	/^	ThrPool* dispatchpool_;$/;"	m	class:rpcs
djob_t	rpc/rpc.h	/^		djob_t (connection *c, char *b, int bsz):buf(b),sz(bsz),conn(c) {}$/;"	f	struct:rpcs::djob_t
djob_t	rpc/rpc.h	/^	struct djob_t {$/;"	s	class:rpcs
do_worker	rpc/thr_pool.cc	/^do_worker(void *arg)$/;"	f	file:
done	rpc/rpc.h	/^			bool done;$/;"	m	struct:rpcc::caller
done_handle	handle.cc	/^handle_mgr::done_handle(struct hinfo *h)$/;"	f	class:handle_mgr
dst	lock_demo.cc	/^std::string dst;$/;"	v
dst	lock_tester.cc	/^std::string dst;$/;"	v
dst	rpc/rpctest.cc	/^struct sockaddr_in dst; \/\/server's ip address$/;"	v	typeref:struct:sockaddr_in
dst_	rpc/rpc.h	/^		sockaddr_in dst_;$/;"	m	class:rpcc
dup_req_	rpc/rpc.h	/^                struct request dup_req_;$/;"	m	class:rpcc	typeref:struct:rpcc::request
ec	yfs_client.h	/^  extent_client *ec;$/;"	m	class:yfs_client
enq	rpc/fifo.h	/^fifo<T>::enq(T e, bool blocking)$/;"	f	class:fifo
extent_client	extent_client.cc	/^extent_client::extent_client(std::string dst)$/;"	f	class:extent_client
extent_client	extent_client.h	/^class extent_client {$/;"	c
extent_client_h	extent_client.h	4;"	d
extent_protocol	extent_protocol.h	/^class extent_protocol {$/;"	c
extent_protocol_h	extent_protocol.h	4;"	d
extent_server	GNUmakefile	/^extent_server=extent_server.cc extent_smain.cc inode_manager.cc$/;"	m
extent_server	extent_server.cc	/^extent_server::extent_server() $/;"	f	class:extent_server
extent_server	extent_server.h	/^class extent_server {$/;"	c
extent_server_h	extent_server.h	4;"	d
extentid_t	extent_protocol.h	/^  typedef unsigned long long extentid_t;$/;"	t	class:extent_protocol
f	rpc/thr_pool.h	/^			void *(*f)(void *); \/\/function point$/;"	m	struct:ThrPool::job_t
failure_test	rpc/rpctest.cc	/^failure_test()$/;"	f
fd_	rpc/connection.h	/^		const int fd_;$/;"	m	class:connection
fdstatus_	rpc/pollmgr.h	/^		int fdstatus_[MAX_POLL_FDS];$/;"	m	class:EPollAIO
fifo	rpc/fifo.h	/^class fifo {$/;"	c
fifo	rpc/fifo.h	/^fifo<T>::fifo(int limit) : max_(limit)$/;"	f	class:fifo
fifo_h	rpc/fifo.h	2;"	d
fileinfo	yfs_client.h	/^  struct fileinfo {$/;"	s	class:yfs_client
filename	yfs_client.cc	/^yfs_client::filename(inum inum)$/;"	f	class:yfs_client
free	lock_client_cache.h	/^        free,$/;"	e	enum:c_state::c_lock_state
free	lock_server.h	/^    free = 0x9003,$/;"	e	enum:state::l_state
free_block	inode_manager.cc	/^block_manager::free_block(uint32_t id)$/;"	f	class:block_manager
free_inode	inode_manager.cc	/^inode_manager::free_inode(uint32_t inum)$/;"	f	class:inode_manager
free_reply_window	rpc/rpc.cc	/^rpcs::free_reply_window(void)$/;"	f	class:rpcs
freed_inode	inode_manager.h	/^  vector<uint32_t> freed_inode;$/;"	m	class:inode_manager
fuseserver_create	fuse.cc	/^fuseserver_create(fuse_req_t req, fuse_ino_t parent, const char *name,$/;"	f
fuseserver_createhelper	fuse.cc	/^fuseserver_createhelper(fuse_ino_t parent, const char *name,$/;"	f
fuseserver_getattr	fuse.cc	/^fuseserver_getattr(fuse_req_t req, fuse_ino_t ino,$/;"	f
fuseserver_lookup	fuse.cc	/^fuseserver_lookup(fuse_req_t req, fuse_ino_t parent, const char *name)$/;"	f
fuseserver_mkdir	fuse.cc	/^fuseserver_mkdir(fuse_req_t req, fuse_ino_t parent, const char *name,$/;"	f
fuseserver_mknod	fuse.cc	/^void fuseserver_mknod( fuse_req_t req, fuse_ino_t parent, $/;"	f
fuseserver_open	fuse.cc	/^fuseserver_open(fuse_req_t req, fuse_ino_t ino,$/;"	f
fuseserver_oper	fuse.cc	/^struct fuse_lowlevel_ops fuseserver_oper;$/;"	v	typeref:struct:fuse_lowlevel_ops
fuseserver_read	fuse.cc	/^fuseserver_read(fuse_req_t req, fuse_ino_t ino, size_t size,$/;"	f
fuseserver_readdir	fuse.cc	/^fuseserver_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,$/;"	f
fuseserver_setattr	fuse.cc	/^fuseserver_setattr(fuse_req_t req, fuse_ino_t ino, struct stat *attr,$/;"	f
fuseserver_statfs	fuse.cc	/^fuseserver_statfs(fuse_req_t req)$/;"	f
fuseserver_unlink	fuse.cc	/^fuseserver_unlink(fuse_req_t req, fuse_ino_t parent, const char *name)$/;"	f
fuseserver_write	fuse.cc	/^fuseserver_write(fuse_req_t req, fuse_ino_t ino,$/;"	f
get	extent_client.cc	/^extent_client::get(extent_protocol::extentid_t eid, std::string &buf)$/;"	f	class:extent_client
get	extent_protocol.h	/^    get,$/;"	e	enum:extent_protocol::rpc_numbers
get	extent_server.cc	/^int extent_server::get(extent_protocol::extentid_t id, std::string &buf)$/;"	f	class:extent_server
getPthreadMutex	lock_server.h	/^    pthread_mutex_t* getPthreadMutex()$/;"	f	class:MutexLock
get_content	rpc/marshall.h	/^		std::string get_content() { $/;"	f	class:marshall
get_cur_block	inode_manager.h	/^  inline uint32_t get_cur_block()$/;"	f	class:block_manager
get_handle	handle.cc	/^handle_mgr::get_handle(std::string m)$/;"	f	class:handle_mgr
get_inode	inode_manager.cc	/^inode_manager::get_inode(uint32_t inum)$/;"	f	class:inode_manager
get_refconn	rpc/rpc.cc	/^rpcc::get_refconn(connection **ch)$/;"	f	class:rpcc
getattr	extent_client.cc	/^extent_client::getattr(extent_protocol::extentid_t eid, $/;"	f	class:extent_client
getattr	extent_protocol.h	/^    getattr,$/;"	e	enum:extent_protocol::rpc_numbers
getattr	extent_server.cc	/^int extent_server::getattr(extent_protocol::extentid_t id, extent_protocol::attr &a)$/;"	f	class:extent_server
getattr	fuse.cc	/^getattr(yfs_client::inum inum, struct stat &st)$/;"	f
getattr	inode_manager.cc	/^inode_manager::getattr(uint32_t inum, extent_protocol::attr &a)$/;"	f	class:inode_manager
getattr	yfs_client.cc	/^int yfs_client::getattr( inum ino, extent_protocol::attr &a)$/;"	f	class:yfs_client
getbit	lock_server.cc	/^bool s_lockInfo::getbit()$/;"	f	class:s_lockInfo
getdir	yfs_client.cc	/^yfs_client::getdir(inum inum, dirinfo &din)$/;"	f	class:yfs_client
getfile	yfs_client.cc	/^yfs_client::getfile(inum inum, fileinfo &fin)$/;"	f	class:yfs_client
gettime_h	gettime.h	2;"	d
got_pdu	rpc/rpc.cc	/^rpcc::got_pdu(connection *c, char *b, int sz)$/;"	f	class:rpcc
got_pdu	rpc/rpc.cc	/^rpcs::got_pdu(connection *c, char *b, int sz)$/;"	f	class:rpcs
h	handle.h	/^  struct hinfo *h;$/;"	m	class:handle	typeref:struct:handle::hinfo
handin_file	GNUmakefile	/^handin_file=lab$(LAB).tgz$/;"	m
handin_ignore	GNUmakefile	/^handin_ignore=$(clean_files) core* *log$/;"	m
handle	handle.cc	/^handle::handle(std::string m) $/;"	f	class:handle
handle	handle.h	/^class handle {$/;"	c
handle_22	rpc/rpctest.cc	/^srv::handle_22(const std::string a, std::string b, std::string &r)$/;"	f	class:srv
handle_bigrep	rpc/rpctest.cc	/^srv::handle_bigrep(const int len, std::string &r)$/;"	f	class:srv
handle_fast	rpc/rpctest.cc	/^srv::handle_fast(const int a, int &r)$/;"	f	class:srv
handle_h	handle.h	24;"	d
handle_mgr	handle.cc	/^handle_mgr::handle_mgr()$/;"	f	class:handle_mgr
handle_mgr	handle.h	/^class handle_mgr {$/;"	c
handle_mutex	handle.h	/^  pthread_mutex_t handle_mutex;$/;"	m	class:handle_mgr
handle_slow	rpc/rpctest.cc	/^srv::handle_slow(const int a, int &r)$/;"	f	class:srv
handler	rpc/rpc.h	/^		handler() { }$/;"	f	class:handler
handler	rpc/rpc.h	/^class handler {$/;"	c
has_callback	rpc/pollmgr.cc	/^PollMgr::has_callback(int fd, poll_flag flag, aio_callback *c)$/;"	f	class:PollMgr
has_space_c_	rpc/fifo.h	/^		pthread_cond_t has_space_c_; \/\/ q is not longer overfull$/;"	m	class:fifo
hfiles1	GNUmakefile	/^hfiles1=rpc\/fifo.h rpc\/connection.h rpc\/rpc.h rpc\/marshall.h rpc\/method_thread.h\\$/;"	m
hfiles2	GNUmakefile	/^hfiles2=yfs_client.h extent_client.h extent_protocol.h extent_server.h$/;"	m
hfiles3	GNUmakefile	/^hfiles3=lock_client_cache.h lock_server_cache.h handle.h tprintf.h$/;"	m
hfiles4	GNUmakefile	/^hfiles4=log.h rsm.h rsm_protocol.h config.h paxos.h paxos_protocol.h rsm_state_transfer.h rsmtest_client.h tprintf.h$/;"	m
hfiles5	GNUmakefile	/^hfiles5=rsm_state_transfer.h rsm_client.h$/;"	m
highfds_	rpc/pollmgr.h	/^		int highfds_;$/;"	m	class:SelectAIO
hinfo	handle.h	/^struct hinfo {$/;"	s
hmap	handle.h	/^  std::map<std::string, struct hinfo *> hmap;$/;"	m	class:handle_mgr
hostname	lock_client_cache.h	/^  std::string hostname;$/;"	m	class:lock_client_cache
huge	test-lab-3-a.c	/^char huge[65536];$/;"	v
id	fuse.cc	/^int id() { $/;"	f
id	lock_client_cache.h	/^  std::string id;$/;"	m	class:lock_client_cache
id	rpc/rpc.h	/^		unsigned int id() { return clt_nonce_; }$/;"	f	class:rpcc
if_revoke_before	lock_client_cache.h	/^    bool if_revoke_before;    $/;"	m	class:c_lockInfo
im	extent_server.h	/^  inode_manager *im;$/;"	m	class:extent_server
in_mem_inode_map	inode_manager.h	/^  std::map<int, inode*> in_mem_inode_map;$/;"	m	class:inode_manager
incref	rpc/connection.cc	/^connection::incref()$/;"	f	class:connection
ind	rpc/marshall.h	/^		int ind() { return _ind;}$/;"	f	class:unmarshall
indirect_read_block	inode_manager.cc	/^void block_manager::indirect_read_block(uint32_t id, uint32_t* buf)$/;"	f	class:block_manager
indirect_read_block	inode_manager.cc	/^void disk::indirect_read_block( blockid_t id, uint32_t *buf)$/;"	f	class:disk
indirect_write_block	inode_manager.cc	/^void block_manager::indirect_write_block(uint32_t id, const uint32_t* buf)$/;"	f	class:block_manager
indirect_write_block	inode_manager.cc	/^void disk::indirect_write_block( blockid_t id, const uint32_t * buf)$/;"	f	class:disk
inode	inode_manager.h	/^typedef struct inode {$/;"	s
inode_h	inode_manager.h	4;"	d
inode_manager	inode_manager.cc	/^inode_manager::inode_manager()$/;"	f	class:inode_manager
inode_manager	inode_manager.h	/^class inode_manager {$/;"	c
inode_t	inode_manager.h	/^} inode_t;$/;"	t	typeref:struct:inode
instance	rpc/pollmgr.cc	/^PollMgr *PollMgr::instance = NULL;$/;"	m	class:PollMgr	file:
instance	rpc/pollmgr.h	/^		static PollMgr *instance;$/;"	m	class:PollMgr
intret	rpc/rpc.h	/^			int intret;$/;"	m	struct:rpcc::caller
inum	yfs_client.h	/^    yfs_client::inum inum;$/;"	m	struct:yfs_client::dirent
inum	yfs_client.h	/^  typedef unsigned long long inum;$/;"	t	class:yfs_client
isFirst	inode_manager.h	/^  bool isFirst;$/;"	m	class:inode_manager
is_silent	lock_client_cache.h	/^    bool is_silent;$/;"	m	class:c_lockInfo
is_watched	rpc/pollmgr.cc	/^EPollAIO::is_watched(int fd, poll_flag flag)$/;"	f	class:EPollAIO
is_watched	rpc/pollmgr.cc	/^SelectAIO::is_watched(int fd, poll_flag flag)$/;"	f	class:SelectAIO
isdead	rpc/connection.cc	/^connection::isdead()$/;"	f	class:connection
isdir	yfs_client.cc	/^yfs_client::isdir(inum inum)$/;"	f	class:yfs_client
isfile	yfs_client.cc	/^yfs_client::isfile(inum inum)$/;"	f	class:yfs_client
islossy	rpc/rpc.h	/^                int islossy() { return lossytest_ > 0; }$/;"	f	class:rpcc
isvalid	rpc/rpc.h	/^                    bool isvalid() { return xid != -1; }$/;"	f	struct:rpcc::request
job_t	rpc/thr_pool.h	/^		struct job_t {$/;"	s	class:ThrPool
jobq_	rpc/thr_pool.h	/^		fifo<job_t> jobq_;$/;"	m	class:ThrPool
jsl_log	rpc/jsl_log.h	14;"	d
jsl_set_debug	rpc/jsl_log.cc	/^jsl_set_debug(int level) {$/;"	f
l_state	lock_server.h	/^enum l_state$/;"	g	class:state
lab1_tester	GNUmakefile	/^lab1_tester=lab1_tester.cc extent_client.cc extent_server.cc inode_manager.cc$/;"	m
labdir	GNUmakefile	/^labdir=$(shell basename $(PWD))$/;"	m
last_port	lock_client_cache.cc	/^int lock_client_cache::last_port = 0;$/;"	m	class:lock_client_cache	file:
last_port	lock_client_cache.h	/^  static int last_port;$/;"	m	class:lock_client_cache
lc	lock_demo.cc	/^lock_client *lc;$/;"	v
lc	lock_tester.cc	/^lock_client_cache **lc = new lock_client_cache * [nt];$/;"	v
lc	yfs_client.h	/^  lock_client *lc;$/;"	m	class:yfs_client
listener_	rpc/rpc.h	/^	tcpsconn* listener_;$/;"	m	class:rpcs
lock	lock_server.h	/^    void lock()$/;"	f	class:MutexLock
lock_client	lock_client.cc	/^lock_client::lock_client(std::string dst)$/;"	f	class:lock_client
lock_client	lock_client.h	/^class lock_client {$/;"	c
lock_client_cache	lock_client_cache.cc	/^lock_client_cache::lock_client_cache(std::string xdst, $/;"	f	class:lock_client_cache
lock_client_cache	lock_client_cache.h	/^class lock_client_cache : public lock_client {$/;"	c
lock_client_cache_h	lock_client_cache.h	5;"	d
lock_client_h	lock_client.h	4;"	d
lock_demo	GNUmakefile	/^lock_demo=lock_demo.cc lock_client.cc$/;"	m
lock_protocol	lock_protocol.h	/^class lock_protocol {$/;"	c
lock_protocol_h	lock_protocol.h	4;"	d
lock_release_user	lock_client_cache.h	/^class lock_release_user {$/;"	c
lock_server	GNUmakefile	/^lock_server=lock_server.cc lock_smain.cc$/;"	m
lock_server	lock_server.cc	/^lock_server::lock_server():$/;"	f	class:lock_server
lock_server	lock_server.h	/^class lock_server {$/;"	c
lock_server_cache	lock_server_cache.cc	/^lock_server_cache::lock_server_cache()$/;"	f	class:lock_server_cache
lock_server_cache	lock_server_cache.h	/^class lock_server_cache {$/;"	c
lock_server_cache_h	lock_server_cache.h	2;"	d
lock_server_h	lock_server.h	5;"	d
lock_state	lock_client_cache.h	/^    int lock_state;$/;"	m	class:c_lockInfo
lock_state	lock_server.h	/^        int lock_state;$/;"	m	class:s_lockInfo
lock_tester	GNUmakefile	/^lock_tester=lock_tester.cc lock_client.cc$/;"	m
locked	lock_client_cache.h	/^        locked,$/;"	e	enum:c_state::c_lock_state
lockid_t	lock_protocol.h	/^  typedef unsigned long long lockid_t;$/;"	t	class:lock_protocol
lockinfo_map	lock_client_cache.h	/^  std::map<lock_protocol::lockid_t, c_lockInfo> lockinfo_map;$/;"	m	class:lock_client_cache
lockinfo_map	lock_server.h	/^  std::map<lock_protocol::lockid_t, s_lockInfo> lockinfo_map;$/;"	m	class:lock_server
lockinfo_map	lock_server_cache.h	/^  std::map<lock_protocol::lockid_t, s_lockInfo> lockinfo_map;$/;"	m	class:lock_server_cache
lookup	yfs_client.cc	/^yfs_client::lookup(inum parent, const char *name, bool &found, inum &ino_out)$/;"	f	class:yfs_client
lossy	rpc/connection.h	/^	int lossy;$/;"	m	struct:bundle
lossy_	rpc/connection.h	/^		const int lossy_;$/;"	m	class:connection
lossy_	rpc/connection.h	/^		int lossy_;$/;"	m	class:tcpsconn
lossy_test	rpc/rpctest.cc	/^lossy_test()$/;"	f
lossytest_	rpc/rpc.h	/^		int lossytest_;$/;"	m	class:rpcc
lossytest_	rpc/rpc.h	/^	int lossytest_; $/;"	m	class:rpcs
lu	lock_client_cache.h	/^  class lock_release_user *lu;$/;"	m	class:lock_client_cache	typeref:class:lock_client_cache::lock_release_user
m	handle.h	/^  std::string m;$/;"	m	struct:hinfo
m	rpc/method_thread.h	/^				void (C::*m)(A1 a1, A2 a2);$/;"	m	class:__anon5::XXX
m	rpc/rpc.h	/^			pthread_mutex_t m;$/;"	m	struct:rpcc::caller
m_	rpc/connection.h	/^		pthread_mutex_t m_;$/;"	m	class:connection
m_	rpc/connection.h	/^		pthread_mutex_t m_;$/;"	m	class:tcpsconn
m_	rpc/fifo.h	/^		pthread_mutex_t m_;$/;"	m	class:fifo
m_	rpc/pollmgr.h	/^		pthread_mutex_t m_;$/;"	m	class:PollMgr
m_	rpc/pollmgr.h	/^		pthread_mutex_t m_;$/;"	m	class:SelectAIO
m_	rpc/rpc.h	/^		pthread_mutex_t m_; \/\/ protect insert\/delete to calls[]$/;"	m	class:rpcc
m_	rpc/slock.h	/^		pthread_mutex_t *m_;$/;"	m	struct:ScopedLock
main	extent_smain.cc	/^main(int argc, char *argv[])$/;"	f
main	fuse.cc	/^main(int argc, char *argv[])$/;"	f
main	lock_demo.cc	/^main(int argc, char *argv[])$/;"	f
main	lock_smain.cc	/^main(int argc, char *argv[])$/;"	f
main	lock_tester.cc	/^main(int argc, char *argv[])$/;"	f
main	rpc/rpctest.cc	/^main(int argc, char *argv[])$/;"	f
main	test-lab-3-a.c	/^main(int argc, char *argv[])$/;"	f
main	test-lab-3-b.c	/^main(int argc, char *argv[])$/;"	f
make_sockaddr	rpc/rpc.cc	/^make_sockaddr(const char *host, const char *port, struct sockaddr_in *dst){$/;"	f
make_sockaddr	rpc/rpc.cc	/^make_sockaddr(const char *hostandport, struct sockaddr_in *dst){$/;"	f
marshall	rpc/marshall.h	/^		marshall() {$/;"	f	class:marshall
marshall	rpc/marshall.h	/^class marshall {$/;"	c
marshall_h	rpc/marshall.h	2;"	d
max_	rpc/fifo.h	/^		unsigned int max_; \/\/maximum capacity of the queue, block enq threads if exceeds this limit$/;"	m	class:fifo
method_thread	rpc/method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)())$/;"	f
method_thread	rpc/method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)(A), A a)$/;"	f
method_thread	rpc/method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)(A1 , A2 ), A1 a1, A2 a2)$/;"	f
method_thread	rpc/method_thread.h	/^method_thread(C *o, bool detach, void (C::*m)(A1 , A2, A3 ), A1 a1, A2 a2, A3 a3)$/;"	f
method_thread_child	rpc/method_thread.h	/^method_thread_child()$/;"	f
method_thread_h	rpc/method_thread.h	2;"	d
method_thread_parent	rpc/method_thread.h	/^method_thread_parent(void *(*fn)(void *), void *arg, bool detach)$/;"	f
mgr	handle.cc	/^handle_mgr mgr;$/;"	v
mgr	rpc/connection.h	/^	chanmgr *mgr;$/;"	m	struct:bundle
mgr_	rpc/connection.h	/^		chanmgr *mgr_;$/;"	m	class:connection
mgr_	rpc/connection.h	/^		chanmgr *mgr_;$/;"	m	class:tcpsconn
min	fuse.cc	386;"	d	file:
mtime	extent_protocol.h	/^    unsigned int mtime;$/;"	m	struct:extent_protocol::attr
mtime	inode_manager.h	/^  unsigned int mtime;$/;"	m	struct:inode
mtime	yfs_client.h	/^    unsigned long mtime;$/;"	m	struct:yfs_client::dirinfo
mtime	yfs_client.h	/^    unsigned long mtime;$/;"	m	struct:yfs_client::fileinfo
mutex2_	lock_client_cache.h	/^  MutexLock mutex2_;\/\/seperate lock for acquiring and releasing$/;"	m	class:lock_client_cache
mutex2_	lock_server_cache.h	/^  MutexLock mutex2_;$/;"	m	class:lock_server_cache
mutex3_	lock_client_cache.h	/^  MutexLock mutex3_;$/;"	m	class:lock_client_cache
mutex_	lock_client_cache.h	/^        MutexLock mutex_;$/;"	m	class:c_lockInfo
mutex_	lock_client_cache.h	/^  MutexLock mutex_;$/;"	m	class:lock_client_cache
mutex_	lock_server.h	/^        MutexLock mutex_;$/;"	m	class:Condition
mutex_	lock_server.h	/^        MutexLock mutex_;$/;"	m	class:lock_server
mutex_	lock_server.h	/^        MutexLock mutex_;$/;"	m	class:s_lockInfo
mutex_	lock_server.h	/^        MutexLock& mutex_;$/;"	m	class:MutexLockGuard
mutex_	lock_server.h	/^    pthread_mutex_t mutex_;$/;"	m	class:MutexLock
mutex_	lock_server_cache.h	/^  MutexLock mutex_;  $/;"	m	class:lock_server_cache
myid	fuse.cc	/^int myid;$/;"	v
myid	yfs_client.h	/^  int myid;$/;"	m	class:yfs_client
n2i	yfs_client.cc	/^yfs_client::n2i(std::string n)$/;"	f	class:yfs_client
nacquire	lock_server.h	/^  int nacquire;$/;"	m	class:lock_server
nacquire	lock_server_cache.h	/^  int nacquire;$/;"	m	class:lock_server_cache
name	yfs_client.h	/^    std::string name;$/;"	m	struct:yfs_client::dirent
nblocks	inode_manager.h	/^  uint32_t nblocks;$/;"	m	struct:superblock
ninodes	inode_manager.h	/^  uint32_t ninodes;$/;"	m	struct:superblock
non_empty_c_	rpc/fifo.h	/^		pthread_cond_t non_empty_c_; \/\/ q went non-empty$/;"	m	class:fifo
nonce_	rpc/rpc.h	/^	unsigned int nonce_;$/;"	m	class:rpcs
none	lock_client_cache.h	/^        none = 0x10000,$/;"	e	enum:c_state::c_lock_state
notify	lock_server.h	/^        void notify()$/;"	f	class:Condition
notifyAll	lock_server.h	/^        void notifyAll()$/;"	f	class:Condition
nt	lock_tester.cc	/^int nt = 6; \/\/XXX: lab1's rpc handlers are blocking. Since rpcs uses a thread pool of 10 threads, we cannot test more than 10 blocking rpc.$/;"	v
nthreads_	rpc/thr_pool.h	/^		int nthreads_;$/;"	m	class:ThrPool
o	rpc/method_thread.h	/^				C *o;$/;"	m	class:__anon5::XXX
ok	rpc/marshall.h	/^		bool ok() { return _ok; }$/;"	f	class:unmarshall
okdone	rpc/rpc.cc	/^unmarshall::okdone()$/;"	f	class:unmarshall
oldsrv_failure	rpc/rpc.h	/^		static const int oldsrv_failure = -5;$/;"	m	class:rpc_const
operator <	rpc/rpc.cc	/^bool operator<(const sockaddr_in &a, const sockaddr_in &b){$/;"	f
operator <<	extent_protocol.h	/^operator<<(marshall &m, extent_protocol::attr a)$/;"	f
operator <<	rpc/marshall.h	/^operator<<(marshall &m, const std::map<A,B> &d) {$/;"	f
operator <<	rpc/marshall.h	/^operator<<(marshall &m, std::vector<C> v)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, bool x)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, char x)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, const std::string &s)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, int x)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, short x)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, unsigned char x)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, unsigned int x)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, unsigned long long x)$/;"	f
operator <<	rpc/rpc.cc	/^operator<<(marshall &m, unsigned short x)$/;"	f
operator >>	extent_protocol.h	/^operator>>(unmarshall &u, extent_protocol::attr &a)$/;"	f
operator >>	rpc/marshall.h	/^operator>>(unmarshall &u, std::map<A,B> &d) {$/;"	f
operator >>	rpc/marshall.h	/^operator>>(unmarshall &u, std::vector<C> &v)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, bool &x)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, char &x)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, int &x)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, short &x)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, std::string &s)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, unsigned char &x)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, unsigned int &x)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, unsigned long long &x)$/;"	f
operator >>	rpc/rpc.cc	/^operator>>(unmarshall &u, unsigned short &x)$/;"	f
p	fuse.cc	/^    char *p;$/;"	m	struct:dirbuf	file:
pack	rpc/rpc.cc	/^marshall::pack(int x)$/;"	f	class:marshall
pack_reply_header	rpc/marshall.h	/^		void pack_reply_header(const reply_header &h) {$/;"	f	class:marshall
pack_req_header	rpc/marshall.h	/^		void pack_req_header(const req_header &h) {$/;"	f	class:marshall
pcond_	lock_server.h	/^        pthread_cond_t pcond_;$/;"	m	class:Condition
pending_change_	rpc/pollmgr.h	/^		bool pending_change_;$/;"	m	class:PollMgr
pipe_	rpc/connection.h	/^		int pipe_[2];$/;"	m	class:tcpsconn
pipefd_	rpc/pollmgr.h	/^		int pipefd_[2];$/;"	m	class:SelectAIO
poll_flag	rpc/pollmgr.h	/^} poll_flag;$/;"	t	typeref:enum:__anon3
poll_flag_to_event	rpc/pollmgr.cc	/^int poll_flag_to_event(poll_flag flag)$/;"	f	file:
pollfd_	rpc/pollmgr.h	/^		int pollfd_;$/;"	m	class:EPollAIO
pollmgr_h	rpc/pollmgr.h	2;"	d
pollmgr_is_initialized	rpc/pollmgr.cc	/^static pthread_once_t pollmgr_is_initialized = PTHREAD_ONCE_INIT;$/;"	v	file:
port	rpc/rpctest.cc	/^int port;$/;"	v
port_	rpc/rpc.h	/^	int port_;$/;"	m	class:rpcs
proc	rpc/marshall.h	/^	int proc;$/;"	m	struct:req_header
process_accept	rpc/connection.cc	/^tcpsconn::process_accept()$/;"	f	class:tcpsconn
procs_	rpc/rpc.h	/^	std::map<int, handler *> procs_;$/;"	m	class:rpcs
procs_m_	rpc/rpc.h	/^	pthread_mutex_t procs_m_; \/\/ protect insert\/delete to procs[]$/;"	m	class:rpcs
put	extent_client.cc	/^extent_client::put(extent_protocol::extentid_t eid, std::string buf)$/;"	f	class:extent_client
put	extent_protocol.h	/^    put = 0x6001,$/;"	e	enum:extent_protocol::rpc_numbers
put	extent_server.cc	/^int extent_server::put(extent_protocol::extentid_t id, std::string buf, int &)$/;"	f	class:extent_server
put_inode	inode_manager.cc	/^inode_manager::put_inode(uint32_t inum, struct inode *ino)$/;"	f	class:inode_manager
q_	rpc/fifo.h	/^		std::list<T> q_;$/;"	m	class:fifo
rawbyte	rpc/rpc.cc	/^marshall::rawbyte(unsigned char x)$/;"	f	class:marshall
rawbyte	rpc/rpc.cc	/^unmarshall::rawbyte()$/;"	f	class:unmarshall
rawbytes	rpc/rpc.cc	/^marshall::rawbytes(const char *p, int n)$/;"	f	class:marshall
rawbytes	rpc/rpc.cc	/^unmarshall::rawbytes(std::string &ss, unsigned int n)$/;"	f	class:unmarshall
reachable_	rpc/rpc.h	/^		bool reachable_;$/;"	m	class:rpcc
reachable_	rpc/rpc.h	/^	bool reachable_;$/;"	m	class:rpcs
read	yfs_client.cc	/^yfs_client::read(inum ino, size_t size, off_t off, std::string &data)$/;"	f	class:yfs_client
read_block	inode_manager.cc	/^block_manager::read_block(uint32_t id, char *buf)$/;"	f	class:block_manager
read_block	inode_manager.cc	/^disk::read_block(blockid_t id, char *buf)$/;"	f	class:disk
read_cb	rpc/connection.cc	/^connection::read_cb(int s)$/;"	f	class:connection
read_file	inode_manager.cc	/^inode_manager::read_file(uint32_t inum, char **buf_out, int *size)$/;"	f	class:inode_manager
readdir	yfs_client.cc	/^yfs_client::readdir(inum dir, std::list<dirent> &list)$/;"	f	class:yfs_client
readpdu	rpc/connection.cc	/^connection::readpdu()$/;"	f	class:connection
ready_	rpc/pollmgr.h	/^		struct epoll_event ready_[MAX_POLL_FDS];$/;"	m	class:EPollAIO	typeref:struct:EPollAIO::epoll_event
reap	test-lab-3-a.c	/^reap (int pid)$/;"	f
reap	test-lab-3-b.c	/^reap (int pid)$/;"	f
ref	rpc/connection.cc	/^connection::ref()$/;"	f	class:connection
ref_m_	rpc/connection.h	/^		pthread_mutex_t ref_m_;$/;"	m	class:connection
refcnt	handle.h	/^  int refcnt;$/;"	m	struct:hinfo
refno_	rpc/connection.h	/^		int refno_;$/;"	m	class:connection
reg	rpc/rpc.h	/^rpcs::reg(unsigned int proc, S*sob, int (S::*meth)(const A1 a1, R & r))$/;"	f	class:rpcs
reg	rpc/rpc.h	/^rpcs::reg(unsigned int proc, S*sob, int (S::*meth)(const A1 a1, const A2 a2, $/;"	f	class:rpcs
reg1	rpc/rpc.cc	/^rpcs::reg1(unsigned int proc, handler *h)$/;"	f	class:rpcs
release	lock_client.cc	/^lock_client::release(lock_protocol::lockid_t lid)$/;"	f	class:lock_client
release	lock_client_cache.cc	/^lock_client_cache::release(lock_protocol::lockid_t lid, int cid)$/;"	f	class:lock_client_cache
release	lock_protocol.h	/^    release,$/;"	e	enum:lock_protocol::rpc_numbers
release	lock_server.cc	/^lock_protocol::status lock_server::release( int clt, lock_protocol::lockid_t lid, int &r)$/;"	f	class:lock_server
release	lock_server_cache.cc	/^lock_server_cache::release(std::string id, lock_protocol::lockid_t lid, $/;"	f	class:lock_server_cache
releasing	lock_client_cache.h	/^        releasing,$/;"	e	enum:c_state::c_lock_state
remove	extent_client.cc	/^extent_client::remove(extent_protocol::extentid_t eid)$/;"	f	class:extent_client
remove	extent_protocol.h	/^    remove,$/;"	e	enum:extent_protocol::rpc_numbers
remove	extent_server.cc	/^int extent_server::remove(extent_protocol::extentid_t id, int &)$/;"	f	class:extent_server
remove_file	inode_manager.cc	/^inode_manager::remove_file(uint32_t inum)$/;"	f	class:inode_manager
reply_buf_limited	fuse.cc	/^int reply_buf_limited(fuse_req_t req, const char *buf, size_t bufsize,$/;"	f
reply_header	rpc/marshall.h	/^	reply_header(int x=0, int r=0): xid(x), ret(r) {}$/;"	f	struct:reply_header
reply_header	rpc/marshall.h	/^struct reply_header {$/;"	s
reply_t	rpc/rpc.h	/^		reply_t (unsigned int _xid) {$/;"	f	struct:rpcs::reply_t
reply_t	rpc/rpc.h	/^	struct reply_t {$/;"	s	class:rpcs
reply_window_	rpc/rpc.h	/^	std::map<unsigned int, std::list<reply_t> > reply_window_;$/;"	m	class:rpcs
reply_window_m_	rpc/rpc.h	/^	pthread_mutex_t reply_window_m_; \/\/ protect reply window et al$/;"	m	class:rpcs
req_header	rpc/marshall.h	/^	req_header(int x=0, int p=0, int c = 0, int s = 0, int xi = 0):$/;"	f	struct:req_header
req_header	rpc/marshall.h	/^struct req_header {$/;"	s
request	rpc/rpc.h	/^                    request() { clear(); }$/;"	f	struct:rpcc::request
request	rpc/rpc.h	/^                struct request {$/;"	s	class:rpcc
ret	rpc/marshall.h	/^	int ret;$/;"	m	struct:reply_header
retrans_	rpc/rpc.h	/^		bool retrans_;$/;"	m	class:rpcc
retry	lock_client_cache.h	/^        retry$/;"	e	enum:c_state::c_lock_state
retry	lock_protocol.h	/^        retry = 0x8002$/;"	e	enum:rlock_protocol::rpc_numbers
retry	lock_server.h	/^    retry$/;"	e	enum:state::l_state
retry_handler	lock_client_cache.cc	/^lock_client_cache::retry_handler(lock_protocol::lockid_t lid, $/;"	f	class:lock_client_cache
revoke	lock_protocol.h	/^        revoke = 0x8001,$/;"	e	enum:rlock_protocol::rpc_numbers
revoke_handler	lock_client_cache.cc	/^lock_client_cache::revoke_handler(lock_protocol::lockid_t lid, $/;"	f	class:lock_client_cache
rfds_	rpc/pollmgr.h	/^		fd_set rfds_;$/;"	m	class:SelectAIO
rlock_port	lock_client_cache.h	/^  int rlock_port;$/;"	m	class:lock_client_cache
rlock_protocol	lock_protocol.h	/^class rlock_protocol {$/;"	c
rpc_checksum_t	rpc/marshall.h	/^typedef uint64_t rpc_checksum_t;$/;"	t
rpc_const	rpc/rpc.h	/^class rpc_const {$/;"	c
rpc_h	rpc/rpc.h	2;"	d
rpc_numbers	extent_protocol.h	/^  enum rpc_numbers {$/;"	g	class:extent_protocol
rpc_numbers	lock_protocol.h	/^    enum rpc_numbers {$/;"	g	class:rlock_protocol
rpc_numbers	lock_protocol.h	/^  enum rpc_numbers {$/;"	g	class:lock_protocol
rpc_sz_t	rpc/marshall.h	/^typedef int rpc_sz_t;$/;"	t
rpcbind	rpc/rpc.cc	/^rpcs::rpcbind(int a, int &r)$/;"	f	class:rpcs
rpcc	rpc/rpc.cc	/^rpcc::rpcc(sockaddr_in d, bool retrans) : $/;"	f	class:rpcc
rpcc	rpc/rpc.h	/^class rpcc : public chanmgr {$/;"	c
rpclib	GNUmakefile	/^rpclib=rpc\/rpc.cc rpc\/connection.cc rpc\/pollmgr.cc rpc\/thr_pool.cc rpc\/jsl_log.cc gettime.cc$/;"	m
rpcs	rpc/rpc.cc	/^rpcs::rpcs(unsigned int p1, int count)$/;"	f	class:rpcs
rpcs	rpc/rpc.h	/^class rpcs : public chanmgr {$/;"	c
rpcstate_t	rpc/rpc.h	/^	} rpcstate_t;$/;"	t	class:rpcs	typeref:enum:rpcs::__anon4
rpctest	GNUmakefile	/^rpc\/rpctest=rpc\/rpctest.cc$/;"	m
rpdu_	rpc/connection.h	/^		charbuf rpdu_;$/;"	m	class:connection
rsm_files	GNUmakefile	/^rsm_files = rsm.cc paxos.cc config.cc log.cc handle.cc$/;"	m
rsm_tester	GNUmakefile	/^rsm_tester=rsm_tester.cc rsmtest_client.cc$/;"	m
s_lockInfo	lock_server.h	/^        s_lockInfo():lock_state(state::used){};$/;"	f	class:s_lockInfo
s_lockInfo	lock_server.h	/^class s_lockInfo$/;"	c
safebind	handle.cc	/^handle::safebind()$/;"	f	class:handle
sb	inode_manager.h	/^  struct superblock sb;$/;"	m	class:block_manager	typeref:struct:block_manager::superblock
send	rpc/connection.cc	/^connection::send(char *b, int sz)$/;"	f	class:connection
send_complete_	rpc/connection.h	/^		pthread_cond_t send_complete_;$/;"	m	class:connection
send_wait_	rpc/connection.h	/^		pthread_cond_t send_wait_;$/;"	m	class:connection
server	rpc/rpctest.cc	/^rpcs *server;  \/\/ server rpc object$/;"	v
service	rpc/rpctest.cc	/^srv service;$/;"	v
set	lock_client_cache.cc	/^void c_lockInfo::set(int status)$/;"	f	class:c_lockInfo
set	lock_server.cc	/^void s_lockInfo::set(int status)$/;"	f	class:s_lockInfo
set_client	lock_server.h	/^        void set_client(string id)$/;"	f	class:s_lockInfo
set_rand_seed	rpc/rpc.cc	/^void set_rand_seed()$/;"	f
set_reachable	rpc/rpc.h	/^		void set_reachable(bool r) { reachable_ = r; }$/;"	f	class:rpcc
set_reachable	rpc/rpc.h	/^	void set_reachable(bool r) { reachable_ = r; }$/;"	f	class:rpcs
setattr	extent_client.cc	/^extent_protocol::status extent_client::setattr(extent_protocol::extentid_t eid, extent_protocol::attr &a)$/;"	f	class:extent_client
setattr	extent_server.cc	/^int extent_server::setattr(extent_protocol::extentid_t id, extent_protocol::attr &a )$/;"	f	class:extent_server
setattr	inode_manager.cc	/^void inode_manager::setattr(uint32_t inum, extent_protocol::attr &a )$/;"	f	class:inode_manager
setattr	yfs_client.cc	/^yfs_client::setattr(inum ino, size_t size)$/;"	f	class:yfs_client
setbit	lock_server.cc	/^void s_lockInfo::setbit()$/;"	f	class:s_lockInfo
simple_tests	rpc/rpctest.cc	/^simple_tests(rpcc *c)$/;"	f
size	extent_protocol.h	/^    unsigned int size;$/;"	m	struct:extent_protocol::attr
size	fuse.cc	/^    size_t size;$/;"	m	struct:dirbuf	file:
size	inode_manager.h	/^  uint32_t size;$/;"	m	struct:superblock
size	inode_manager.h	/^  unsigned int size;$/;"	m	struct:inode
size	rpc/fifo.h	/^fifo<T>::size()$/;"	f	class:fifo
size	rpc/marshall.h	/^		int size() { return _ind;}$/;"	f	class:marshall
size	rpc/marshall.h	/^		int size() { return _sz;}$/;"	f	class:unmarshall
size	yfs_client.h	/^    unsigned long long size;$/;"	m	struct:yfs_client::fileinfo
solong	rpc/connection.h	/^			int solong; \/\/amount of bytes written or read so far$/;"	m	struct:connection::charbuf
split	yfs_client.cc	/^vector<string> yfs_client::split(string &str, string trunc)$/;"	f	class:yfs_client
split_str	yfs_client.cc	/^string yfs_client::split_str(string &str, string trunc)$/;"	f	class:yfs_client
srv	rpc/rpctest.cc	/^class srv {$/;"	c	file:
srv_nonce	rpc/marshall.h	/^	unsigned int srv_nonce;$/;"	m	struct:req_header
srv_nonce_	rpc/rpc.h	/^		unsigned int srv_nonce_;$/;"	m	class:rpcc
startserver	rpc/rpctest.cc	/^void startserver()$/;"	f
stat	lock_client.cc	/^lock_client::stat(lock_protocol::lockid_t lid)$/;"	f	class:lock_client
stat	lock_protocol.h	/^    stat$/;"	e	enum:lock_protocol::rpc_numbers
stat	lock_server.cc	/^lock_server::stat(int clt, lock_protocol::lockid_t lid, int &r)$/;"	f	class:lock_server
stat	lock_server_cache.cc	/^lock_server_cache::stat(lock_protocol::lockid_t lid, int &r)$/;"	f	class:lock_server_cache
state	lock_server.h	/^class state$/;"	c
static_max	lang/algorithm.h	/^struct static_max$/;"	s
static_min	lang/algorithm.h	/^struct static_min$/;"	s
status	extent_protocol.h	/^  typedef int status;$/;"	t	class:extent_protocol
status	lock_protocol.h	/^    typedef int status;$/;"	t	class:rlock_protocol
status	lock_protocol.h	/^  typedef int status;$/;"	t	class:lock_protocol
status	yfs_client.h	/^  typedef int status;$/;"	t	class:yfs_client
std	test-lab-3-a.c	/^using namespace std;$/;"	v
str	rpc/marshall.h	/^		std::string str() {$/;"	f	class:marshall
superblock	inode_manager.h	/^typedef struct superblock {$/;"	s
superblock_t	inode_manager.h	/^} superblock_t;$/;"	t	typeref:struct:superblock
sz	rpc/connection.h	/^			int sz;$/;"	m	struct:connection::charbuf
sz	rpc/rpc.h	/^		int sz;         \/\/ the size of reply buffer$/;"	m	struct:rpcs::reply_t
sz	rpc/rpc.h	/^		int sz;$/;"	m	struct:rpcs::djob_t
takeJob	rpc/thr_pool.cc	/^ThrPool::takeJob(job_t *j)$/;"	f	class:ThrPool
take_buf	rpc/marshall.h	/^		void take_buf(char **b, int *s) {$/;"	f	class:marshall
take_buf	rpc/marshall.h	/^		void take_buf(char **b, int *sz) {$/;"	f	class:unmarshall
take_content	rpc/marshall.h	/^		void take_content(const std::string &s) {$/;"	f	class:unmarshall
take_in	rpc/rpc.cc	/^unmarshall::take_in(unmarshall &another)$/;"	f	class:unmarshall
tcp	rpc/connection.h	/^	int tcp;$/;"	m	struct:bundle
tcp_	rpc/connection.h	/^		int tcp_; \/\/file desciptor for accepting connection$/;"	m	class:tcpsconn
tcpsconn	rpc/connection.cc	/^tcpsconn::tcpsconn(chanmgr *m1, int port, int lossytest) $/;"	f	class:tcpsconn
tcpsconn	rpc/connection.h	/^class tcpsconn {$/;"	c
test-lab-3-b	GNUmakefile	/^test-lab-3-b=test-lab-3-b.c$/;"	m
test-lab-3-c	GNUmakefile	/^test-lab-3-c=test-lab-3-c.c$/;"	m
test1	lock_tester.cc	/^test1(void)$/;"	f
test2	lock_tester.cc	/^test2(void *x) $/;"	f
test3	lock_tester.cc	/^test3(void *x)$/;"	f
test4	lock_tester.cc	/^test4(void *x)$/;"	f
test5	lock_tester.cc	/^test5(void *x)$/;"	f
testmarshall	rpc/rpctest.cc	/^testmarshall()$/;"	f
th_	rpc/connection.h	/^		pthread_t th_;$/;"	m	class:tcpsconn
th_	rpc/pollmgr.h	/^		pthread_t th_;$/;"	m	class:PollMgr
th_	rpc/thr_pool.h	/^		std::vector<pthread_t> th_;$/;"	m	class:ThrPool
timeout_failure	rpc/rpc.h	/^		static const int timeout_failure = -1;$/;"	m	class:rpc_const
to	rpc/rpc.h	/^			int to;$/;"	m	struct:rpcc::TO
to	rpc/rpc.h	/^		static TO to(int x) { TO t; t.to = x; return t;}$/;"	f	class:rpcc
to_max	rpc/rpc.cc	/^const rpcc::TO rpcc::to_max = { 120000 };$/;"	m	class:rpcc	file:
to_max	rpc/rpc.h	/^		static const TO to_max;$/;"	m	class:rpcc
to_min	rpc/rpc.cc	/^const rpcc::TO rpcc::to_min = { 1000 };$/;"	m	class:rpcc	file:
to_min	rpc/rpc.h	/^		static const TO to_min;$/;"	m	class:rpcc
tprintf	tprintf.h	4;"	d
type	extent_protocol.h	/^    uint32_t type;$/;"	m	struct:extent_protocol::attr
type	inode_manager.h	/^  short type;$/;"	m	struct:inode
types	extent_protocol.h	/^  enum types {$/;"	g	class:extent_protocol
un	rpc/rpc.h	/^			unmarshall *un;$/;"	m	struct:rpcc::caller
unlink	yfs_client.cc	/^int yfs_client::unlink(inum parent,const char *name)$/;"	f	class:yfs_client
unlink1	test-lab-3-a.c	/^unlink1(const char *d, const char *f)$/;"	f
unlink1	test-lab-3-b.c	/^unlink1(const char *d, const char *f)$/;"	f
unlinkn	test-lab-3-a.c	/^unlinkn(const char *d, const char *prefix, int nf)$/;"	f
unlinkn	test-lab-3-b.c	/^unlinkn(const char *d, const char *prefix, int nf)$/;"	f
unlock	lock_server.h	/^        void unlock()$/;"	f	class:MutexLockGuard
unlock	lock_server.h	/^    void unlock()$/;"	f	class:MutexLock
unmarshal_args_failure	rpc/rpc.h	/^		static const int unmarshal_args_failure = -2;$/;"	m	class:rpc_const
unmarshal_reply_failure	rpc/rpc.h	/^		static const int unmarshal_reply_failure = -3;$/;"	m	class:rpc_const
unmarshall	rpc/marshall.h	/^		unmarshall(): _buf(NULL),_sz(0),_ind(0),_ok(false) {}$/;"	f	class:unmarshall
unmarshall	rpc/marshall.h	/^		unmarshall(char *b, int sz): _buf(b),_sz(sz),_ind(),_ok(true) {}$/;"	f	class:unmarshall
unmarshall	rpc/marshall.h	/^		unmarshall(const std::string &s) : _buf(NULL),_sz(0),_ind(0),_ok(false) $/;"	f	class:unmarshall
unmarshall	rpc/marshall.h	/^class unmarshall {$/;"	c
unpack	rpc/rpc.cc	/^unmarshall::unpack(int *x)$/;"	f	class:unmarshall
unpack_reply_header	rpc/marshall.h	/^		void unpack_reply_header(reply_header *h) {$/;"	f	class:unmarshall
unpack_req_header	rpc/marshall.h	/^		void unpack_req_header(req_header *h) {$/;"	f	class:unmarshall
unwatch_fd	rpc/pollmgr.cc	/^EPollAIO::unwatch_fd(int fd, poll_flag flag)$/;"	f	class:EPollAIO
unwatch_fd	rpc/pollmgr.cc	/^SelectAIO::unwatch_fd(int fd, poll_flag flag)$/;"	f	class:SelectAIO
update_xid_rep	rpc/rpc.cc	/^rpcc::update_xid_rep(unsigned int xid)$/;"	f	class:rpcc
updatestat	rpc/rpc.cc	/^rpcs::updatestat(unsigned int proc)$/;"	f	class:rpcs
used	lock_server.h	/^    used,$/;"	e	enum:state::l_state
useful	rpc/pollmgr.h	/^		static int useful;$/;"	m	class:PollMgr
useless	rpc/pollmgr.h	/^		static int useless;$/;"	m	class:PollMgr
using_blocks	inode_manager.h	/^  std::map <uint32_t, int> using_blocks;$/;"	m	class:block_manager
value	lang/algorithm.h	/^    static const int value = A > B ? A : B;$/;"	m	struct:static_max
verify_client_h	lang/verify.h	4;"	d
wait	lock_client_cache.cc	/^int lock_client_cache::wait(lock_protocol::lockid_t lid, int cid)$/;"	f	class:lock_client_cache
wait	lock_server.h	/^        void wait()$/;"	f	class:Condition
wait	lock_server_cache.cc	/^void lock_server_cache::wait(lock_protocol::lockid_t, std::string id)$/;"	f	class:lock_server_cache
wait_loop	rpc/pollmgr.cc	/^PollMgr::wait_loop()$/;"	f	class:PollMgr
wait_queue	lock_server.h	/^        std::deque<std::string> wait_queue;\/\/the int is the client's id.        $/;"	m	class:s_lockInfo
wait_ready	rpc/pollmgr.cc	/^EPollAIO::wait_ready(std::vector<int> *readable, std::vector<int> *writable)$/;"	f	class:EPollAIO
wait_ready	rpc/pollmgr.cc	/^SelectAIO::wait_ready(std::vector<int> *readable, std::vector<int> *writable)$/;"	f	class:SelectAIO
waiters_	rpc/connection.h	/^		int waiters_;$/;"	m	class:connection
watch_fd	rpc/pollmgr.cc	/^EPollAIO::watch_fd(int fd, poll_flag flag)$/;"	f	class:EPollAIO
watch_fd	rpc/pollmgr.cc	/^SelectAIO::watch_fd(int fd, poll_flag flag)$/;"	f	class:SelectAIO
wfds_	rpc/pollmgr.h	/^		fd_set wfds_;$/;"	m	class:SelectAIO
wpdu_	rpc/connection.h	/^		charbuf wpdu_;$/;"	m	class:connection
write	yfs_client.cc	/^yfs_client::write(inum ino, size_t size, off_t off, const char *data,$/;"	f	class:yfs_client
write1	test-lab-3-a.c	/^write1(const char *d, const char *f, int start, int n, char c)$/;"	f
write_block	inode_manager.cc	/^block_manager::write_block(uint32_t id, const char *buf)$/;"	f	class:block_manager
write_block	inode_manager.cc	/^disk::write_block(blockid_t id, const char *buf)$/;"	f	class:disk
write_cb	rpc/connection.cc	/^connection::write_cb(int s)$/;"	f	class:connection
write_file	inode_manager.cc	/^inode_manager::write_file(uint32_t inum, const char *buf, int size)$/;"	f	class:inode_manager
write_file_within_direct_size	inode_manager.cc	/^void inode_manager::write_file_within_direct_size(uint32_t inum, const char *buf, int size, inode* cur_inode, uint32_t block_num)$/;"	f	class:inode_manager
writeat	test-lab-2-b.pl	/^sub writeat {$/;"	s
writeone	test-lab-2-b.pl	/^sub writeone {$/;"	s
writepdu	rpc/connection.cc	/^connection::writepdu()$/;"	f	class:connection
xid	rpc/marshall.h	/^	int xid;$/;"	m	struct:reply_header
xid	rpc/marshall.h	/^	int xid;$/;"	m	struct:req_header
xid	rpc/rpc.h	/^			unsigned int xid;$/;"	m	struct:rpcc::caller
xid	rpc/rpc.h	/^		unsigned int xid;$/;"	m	struct:rpcs::reply_t
xid	rpc/rpc.h	/^                    int xid;$/;"	m	struct:rpcc::request
xid_	rpc/rpc.h	/^		unsigned int xid_;$/;"	m	class:rpcc
xid_rep	rpc/marshall.h	/^	int xid_rep;$/;"	m	struct:req_header
xid_rep_done_	rpc/rpc.h	/^                int xid_rep_done_;$/;"	m	class:rpcc
xid_rep_window_	rpc/rpc.h	/^		std::list<unsigned int> xid_rep_window_;$/;"	m	class:rpcc
xxstatus	extent_protocol.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR };$/;"	g	class:extent_protocol
xxstatus	lock_protocol.h	/^    enum xxstatus { OK, RPCERR, RESET };$/;"	g	class:rlock_protocol
xxstatus	lock_protocol.h	/^  enum xxstatus { OK, RETRY, RPCERR, NOENT, IOERR };$/;"	g	class:lock_protocol
xxstatus	yfs_client.h	/^  enum xxstatus { OK, RPCERR, NOENT, IOERR, EXIST };$/;"	g	class:yfs_client
yfs	fuse.cc	/^yfs_client *yfs;$/;"	v
yfs_client	GNUmakefile	/^yfs_client=yfs_client.cc extent_client.cc fuse.cc extent_server.cc inode_manager.cc$/;"	m
yfs_client	yfs_client.cc	/^yfs_client::yfs_client(std::string extent_dst, std::string lock_dst)$/;"	f	class:yfs_client
yfs_client	yfs_client.h	/^class yfs_client {$/;"	c
yfs_client_h	yfs_client.h	2;"	d
yyy	rpc/method_thread.h	/^				static void *yyy(void *vvv) {$/;"	f	class:__anon5::XXX
~Condition	lock_server.h	/^        ~Condition()$/;"	f	class:Condition
~EPollAIO	rpc/pollmgr.cc	/^EPollAIO::~EPollAIO()$/;"	f	class:EPollAIO
~MutexLock	lock_server.h	/^    ~MutexLock()$/;"	f	class:MutexLock
~MutexLockGuard	lock_server.h	/^        ~MutexLockGuard()$/;"	f	class:MutexLockGuard
~PollMgr	rpc/pollmgr.cc	/^PollMgr::~PollMgr()$/;"	f	class:PollMgr
~ScopedLock	rpc/slock.h	/^		~ScopedLock() {$/;"	f	struct:ScopedLock
~SelectAIO	rpc/pollmgr.cc	/^SelectAIO::~SelectAIO()$/;"	f	class:SelectAIO
~ThrPool	rpc/thr_pool.cc	/^ThrPool::~ThrPool()$/;"	f	class:ThrPool
~aio_callback	rpc/pollmgr.h	/^		virtual ~aio_callback() {}$/;"	f	class:aio_callback
~aio_mgr	rpc/pollmgr.h	/^		virtual ~aio_mgr() {}$/;"	f	class:aio_mgr
~caller	rpc/rpc.cc	/^rpcc::caller::~caller()$/;"	f	class:rpcc::caller
~chanmgr	rpc/connection.h	/^		virtual ~chanmgr() {}$/;"	f	class:chanmgr
~connection	rpc/connection.cc	/^connection::~connection()$/;"	f	class:connection
~fifo	rpc/fifo.h	/^fifo<T>::~fifo()$/;"	f	class:fifo
~handle	handle.cc	/^handle::~handle() $/;"	f	class:handle
~handler	rpc/rpc.h	/^		virtual ~handler() { }$/;"	f	class:handler
~lock_client	lock_client.h	/^  virtual ~lock_client() {};$/;"	f	class:lock_client
~lock_client_cache	lock_client_cache.h	/^  virtual ~lock_client_cache() {};$/;"	f	class:lock_client_cache
~lock_release_user	lock_client_cache.h	/^  virtual ~lock_release_user() {};$/;"	f	class:lock_release_user
~lock_server	lock_server.h	/^  ~lock_server() {};$/;"	f	class:lock_server
~marshall	rpc/marshall.h	/^		~marshall() { $/;"	f	class:marshall
~rpcc	rpc/rpc.cc	/^rpcc::~rpcc()$/;"	f	class:rpcc
~rpcs	rpc/rpc.cc	/^rpcs::~rpcs()$/;"	f	class:rpcs
~tcpsconn	rpc/connection.cc	/^tcpsconn::~tcpsconn()$/;"	f	class:tcpsconn
~unmarshall	rpc/marshall.h	/^		~unmarshall() {$/;"	f	class:unmarshall
